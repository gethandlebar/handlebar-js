import z from "zod";
import { AuditEnvelopeSchema } from "./events.base";
import { GovernanceDecisionSchema, SignalSchema } from "./governance-actions";
import { AgentMetrics } from "./run-metrics";

const CountersSchema = z.record(z.string(), z.union([z.string(), z.number()]));

const ToolMetaSchema = z.object({
	redacted: z.boolean(),
	redactedFields: z.array(z.string()).optional(), // JSONpath ish
	sizeBytesApprox: z.number().min(0).optional(),
});

const ToolIdentitySchema = z.object({
	// callId: z.string(), // UUIDv7 with prefix. Should be generated by DB but not in use for now.
	name: z.string(),
	categories: z.array(z.string()).optional(),
});

const ToolArgsSchema = z.record(z.string(), z.unknown());

export const SubjectSchema = z.object({
  subjectType: z.string().max(256), // e.g. "customer", "ticket", "order"
  role: z.string().max(256).optional(), // e.g. "primary" | "source" | "dest"
  value: z.string().max(256), // Data representing the subject. Typically an ID, but doesn't have to be.
  idSystem: z.string().max(256).optional(), // Provenence of subject data for records. e.g. "crm_contact_id"
});

export const HitlMetaSchema = z.object({
	hitlActionId: z.string().optional(), // PK on hitl action.
	fingerprint: z.string().optional(), // Typically agent+tool+args hash
	status: z.enum(["none", "pending", "approved", "denied"]).optional(), // "none" for generated client-side without server acknowledgement.
});


export const ToolDecisionEventSchema = AuditEnvelopeSchema.extend({
	kind: z.literal("tool.decision"),
	data: GovernanceDecisionSchema.extend({
		tool: ToolIdentitySchema,
		args: ToolArgsSchema.optional(),
		argsMeta: ToolMetaSchema.optional(),
    hitl: HitlMetaSchema.optional(),

    subjects: z.array(SubjectSchema).max(100).optional(),
    signals: z.array(SignalSchema).max(100).optional(),

		counters: CountersSchema.optional(),
		latencyMs: z.number().min(0).optional(), // Time in governance
	}),
});

export const ToolResultEventSchema = AuditEnvelopeSchema.extend({
	kind: z.literal("tool.result"),
	data: z.object({
		tool: ToolIdentitySchema,
		hitl: HitlMetaSchema.optional(),
		outcome: z.enum(["success", "error"]),
		durationMs: z.number().min(0).optional(), // tool runtime
    counters: CountersSchema.optional(),
		metrics: AgentMetrics.optional(),
		error: z
			.object({
				name: z.string().optional(),
				message: z.string().optional(),
				stack: z.string().optional(),
			})
			.optional(),
		resultMeta: ToolMetaSchema.optional(),
	}),
});
