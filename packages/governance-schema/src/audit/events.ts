import { z } from "zod";
import {
	EndUserConfigSchema,
	EndUserGroupConfigSchema,
} from "../enduser.types";
import { AuditEnvelopeSchema } from "./events.base";
import { MessageEventSchema } from "./events.llm";
import { GovernanceDecisionSchema } from "./governance-actions";

const CountersSchema = z.record(z.string(), z.union([z.string(), z.number()]));

const ToolMetaSchema = z.object({
	redacted: z.boolean(),
	redactedFields: z.array(z.string()).optional(), // JSONpath ish
	sizeBytesApprox: z.number().min(0).optional(),
});

export const RunStartedEventSchema = AuditEnvelopeSchema.extend({
	kind: z.literal("run.started"),
	data: z.object({
		env: z.enum(["dev", "staging", "prod"]).optional(),
		agent: z.object({
			framework: z.string().optional(),
			version: z.string().optional(),
			id: z.string().optional(),
			name: z.string().optional(),
		}),
		enduser: EndUserConfigSchema.extend({
			// If a group if also provided, the user will be attached to the group.
			group: EndUserGroupConfigSchema.optional(),
		}).optional(),
		model: z
			.object({
				provider: z.string().optional(),
				name: z.string().optional(),
			})
			.optional(),
		adapter: z.object({
			name: z.string(),
			version: z.string().optional(),
		}),
		policy: z
			.object({
				version: z.string().optional(),
				ruleCount: z.number().int().nonnegative().optional(),
				sequenceId: z.string().optional(),
			})
			.optional(),
		request: z
			.object({
				id: z.string().optional(),
				traceparent: z.string().optional(),
			})
			.optional(),
	}),
});

const ToolIdentitySchema = z.object({
	// callId: z.string(), // UUIDv7 with prefix. Should be generated by DB but not in use for now.
	name: z.string(),
	categories: z.array(z.string()).optional(),
});

const ToolArgsSchema = z.record(z.string(), z.unknown());

export const HitlMetaSchema = z.object({
	hitlActionId: z.string().optional(), // PK on hitl action.
	fingerprint: z.string().optional(), // Typically agent+tool+args hash
	status: z.enum(["none", "pending", "approved", "denied"]).optional(), // "none" for generated client-side without server acknowledgement.
});

export const ToolDecisionEventSchema = AuditEnvelopeSchema.extend({
	kind: z.literal("tool.decision"),
	data: GovernanceDecisionSchema.extend({
		tool: ToolIdentitySchema,
		args: ToolArgsSchema.optional(),
		argsMeta: ToolMetaSchema.optional(),
		hitl: HitlMetaSchema.optional(),

		counters: CountersSchema.optional(),
		latencyMs: z.number().min(0).optional(), // Time in governance
	}),
});

export const ToolResultEventSchema = AuditEnvelopeSchema.extend({
	kind: z.literal("tool.result"),
	data: z.object({
		tool: ToolIdentitySchema,
		hitl: HitlMetaSchema.optional(),
		outcome: z.enum(["success", "error"]),
		durationMs: z.number().min(0).optional(), // tool runtime
		counters: CountersSchema.optional(),
		error: z
			.object({
				name: z.string().optional(),
				message: z.string().optional(),
				stack: z.string().optional(),
			})
			.optional(),
		resultMeta: ToolMetaSchema.optional(),
	}),
});

export const RunEndedEventSchema = AuditEnvelopeSchema.extend({
	kind: z.literal("run.ended"),
	data: z.object({
		status: z.enum(["ok", "error", "blocked"]),
		totalSteps: z.number().min(0),
		firstErrorDecisionId: z.string().optional(), // DEPRECATED.
		summary: z.string().optional(),
	}),
});

export const ErrorEventSchema = AuditEnvelopeSchema.extend({
	kind: z.literal("error"),
	data: z.object({
		scope: z.enum(["governance", "adapter", "transport", "agent"]),
		message: z.string(),
		details: z.record(z.string(), z.string()).optional(),
		fatal: z.boolean().optional(),
	}),
});

export const AuditEventSchema = z.discriminatedUnion("kind", [
	RunStartedEventSchema,
	ToolDecisionEventSchema,
	ToolResultEventSchema,
	RunEndedEventSchema,
	ErrorEventSchema,
	MessageEventSchema,
]);

export type AuditEvent = z.infer<typeof AuditEventSchema>;
export type AuditEventByKind = {
	[E in AuditEvent as E["kind"]]: E;
};
